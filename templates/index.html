<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Chesso</title>
  <link href="/static/img/chesspieces/wikipedia/bQ.png" rel="icon" type="image/x-icon" />
  <link href="static/css/bootstrap.min.css" rel="stylesheet" />
  <link href="static/css/styles.css" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/chessground@9.1.1/assets/chessground.base.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/chessground@9.1.1/assets/chessground.brown.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/chessground@9.1.1/assets/chessground.cburnett.css" rel="stylesheet">
</head>

<body>

  <div id="main-container">
    <h1 class="title">Chesso</h1>

    <div id="board-and-moves">

      <div id="board-container"></div>

      <!-- INFO PANEL -->
      <div id="move-list-panel">
        <!-- CAPTURED PIECES -->
        <div id="captured-pieces-display">
          <div class="captured-row">
            <div id="white-captures" class="captured-pieces">
              <span class="piece-letter piece-black">W: </span>
            </div>
          </div>
          <div class="captured-row">
            <div id="black-captures" class="captured-pieces">
              <span class="piece-letter piece-black">B: </span>
            </div>
          </div>
          <div id="material-advantage"></div>
        </div>
        
        <!-- MOVE LIST -->
        <div id="move-list-wrapper">
          <table id="move-list-table">
            <thead>
              <tr>
                <th>#</th>
                <th>White</th>
                <th>Black</th>
              </tr>
            </thead>
            <tbody id="move-list-body"></tbody>
          </table>
        </div>
        <!-- Desktop Flip Button -->
        <div id="move-panel-footer" class="d-none d-md-block">
          <button id="flip-button" class="flip-btn">Flip Board</button>
        </div>
      </div>
    </div>

    <!-- Mobile Flip Button (fixed at bottom) -->
    <div id="mobile-flip-btn" class="d-block d-md-none fixed-bottom p-2" style="background-color: #1f1f1f;">
      <button id="flip-button-mobile" class="btn btn-secondary btn-block flip-btn">Flip Board</button>
    </div>

  </div>
  <!-- PROMOTION -->
  <div id="promotion-overlay" class="hidden">
    <div id="promotion-dialog">
      <p>Choose promotion:</p>
      <div class="promotion-options">
        <button data-piece="q">♕</button>
        <button data-piece="r">♖</button>
        <button data-piece="b">♗</button>
        <button data-piece="n">♘</button>
      </div>
    </div>
  </div>
  <!-- GAME OVER -->
  <div id="gameover-overlay" class="hidden">
    <div id="gameover-dialog">
      <h2 id="gameover-message">White Wins</h2>
      <button id="newgame-button">New Game</button>
    </div>
  </div>

  <script src="static/js/jquery-3.5.1.min.js"></script>
  <script src="static/js/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.1/chess.js"
    integrity="sha384-8sJV/krC8iV2g7t0PolQxFVckDtxhfM5gNHNAFPG2ZS/bScudOjfsB8ewhG2xle8"
    crossorigin="anonymous"></script>
  <script type="module">
    import { Chessground } from 'https://cdn.jsdelivr.net/npm/chessground@9.1.1/dist/chessground.js';

    document.addEventListener('DOMContentLoaded', () => {
      const game = new Chess();
      const boardElement = document.getElementById('board-container');
      const overlay = document.getElementById('promotion-overlay');
      let pendingPromotion = null;
      let isFlipped = false;
      let capturedPieces = { w: [], b: [] };
      
      // Material values for calculating advantage
      const pieceValues = {
        p: 1,   // pawn
        n: 3,   // knight
        b: 3,   // bishop
        r: 5,   // rook
        q: 9,   // queen
        k: 0    // king (no material value)
      };

      // Display symbols for pieces (respecting chess convention)
      const pieceDisplaySymbols = {
        w: {
          p: 'P', n: 'N', b: 'B', r: 'R', q: 'Q'
        },
        b: {
          p: 'p', n: 'n', b: 'b', r: 'r', q: 'q'
        }
      };

      const ground = Chessground(boardElement, {
        draggable: {
          enabled: true,
          showGhost: true
        },
        movable: {
          free: false,
          color: 'white',
          dests: compute_dests(),
          events: {
            after: (orig, dest) => {
              const moves = game.moves({ square: orig, verbose: true });
              const move = moves.find(m => m.to === dest);

              if (move && move.promotion) {
                pendingPromotion = { orig, dest };
                overlay.classList.remove('hidden');
              } else {
                apply_move(orig, dest, 'q'); // normal move
              }
            }
          }
        },
        coordinatesOnSquares: false,
        coordinates: true,
        highlight: {
          lastMove: true,
          check: true
        },
        animation: {
          enabled: true,
          duration: 300
        },
        fen: game.fen()
      });

      function compute_dests() {
        const dests = new Map();
        game.SQUARES.forEach(sq => {
          const moves = game.moves({ square: sq, verbose: true });
          if (moves.length) {
            dests.set(sq, moves.map(m => m.to));
          }
        });
        return dests;
      }

      function apply_move(orig, dest, promotion) {
        const move = game.move({ from: orig, to: dest, promotion });
        if (move) {
          // Check for captures
          if (move.captured) {
            updateCapturedPieces(move.captured, move.color === 'w' ? 'b' : 'w');
          }
          
          ground.set({
            fen: game.fen(),
            movable: {
              color: game.turn() === 'w' ? 'white' : 'black',
              dests: compute_dests()
            }
          });

          check_gameover();
          update_move_list();
          updateMaterialAdvantage();
        }
      }

      function updateCapturedPieces(pieceType, color) {
        capturedPieces[color].push(pieceType);
        displayCapturedPieces();
      }
      
      function displayCapturedPieces() {
        const whiteCapturesElement = document.getElementById('white-captures');
        const blackCapturesElement = document.getElementById('black-captures');
        
        whiteCapturesElement.innerHTML = '<span class="piece-letter piece-black">W: </span>';
        blackCapturesElement.innerHTML = '<span class="piece-letter piece-black">B: </span>';
        
        // Sort pieces by value before displaying
        capturedPieces.w.sort((a, b) => pieceValues[b] - pieceValues[a]);
        capturedPieces.b.sort((a, b) => pieceValues[b] - pieceValues[a]);
        
        // Display white's captured pieces (captured by black)
        capturedPieces.w.forEach(piece => {
          const pieceElem = document.createElement('span');
          pieceElem.className = 'piece-letter piece-white';
          pieceElem.textContent = pieceDisplaySymbols.w[piece] || piece.toUpperCase();
          blackCapturesElement.appendChild(pieceElem);
        });
        
        // Display black's captured pieces (captured by white)
        capturedPieces.b.forEach(piece => {
          const pieceElem = document.createElement('span');
          pieceElem.className = 'piece-letter piece-black';
          pieceElem.textContent = pieceDisplaySymbols.b[piece] || piece.toLowerCase();
          whiteCapturesElement.appendChild(pieceElem);
        });
      }
      
      function updateMaterialAdvantage() {
        const advantageElement = document.getElementById('material-advantage');
        
        // Calculate material advantage
        let whiteMaterial = 0;
        let blackMaterial = 0;
        
        // Add up material for all pieces on the board
        const position = game.board();
        for (let i = 0; i < 8; i++) {
          for (let j = 0; j < 8; j++) {
            const square = position[i][j];
            if (square) {
              if (square.color === 'w') {
                whiteMaterial += pieceValues[square.type];
              } else {
                blackMaterial += pieceValues[square.type];
              }
            }
          }
        }
        
        const advantage = whiteMaterial - blackMaterial;
        
        // Display the advantage
        if (advantage > 0) {
          advantageElement.textContent = `White: +${advantage}`;
          advantageElement.style.color = '#8ff';
        } else if (advantage < 0) {
          advantageElement.textContent = `Black: +${Math.abs(advantage)}`;
          advantageElement.style.color = '#8ff';
        } else {
          advantageElement.textContent = 'Even';
          advantageElement.style.color = '#f5f5f5';
        }
      }

      document.querySelectorAll('.promotion-options button').forEach(btn => {
        btn.addEventListener('click', () => {
          if (pendingPromotion) {
            const piece = btn.dataset.piece;
            apply_move(pendingPromotion.orig, pendingPromotion.dest, piece);
            pendingPromotion = null;
            overlay.classList.add('hidden');
          }
        });
      });

      const gameoverOverlay = document.getElementById('gameover-overlay');
      const gameoverMessage = document.getElementById('gameover-message');
      const newgameButton = document.getElementById('newgame-button');

      // Check if game is over and show overlay
      function check_gameover() {
        if (game.game_over()) {
          const winner = game.in_draw() ? 'Draw' : (game.turn() === 'w' ? 'Black Wins' : 'White Wins');
          gameoverMessage.textContent = winner;
          gameoverOverlay.classList.remove('hidden');

          ground.set({
            movable: { color: null, dests: new Map() } // ⛔ disable interaction
          });
        }
      }

      // New game button resets everything
      newgameButton.addEventListener('click', () => {
        game.reset();
        gameoverOverlay.classList.add('hidden');
        document.getElementById('move-list-body').innerHTML = '';
        
        // Reset captured pieces
        capturedPieces = { w: [], b: [] };
        displayCapturedPieces();
        updateMaterialAdvantage();

        ground.set({
          fen: game.fen(),
          turnColor: 'white',
          draggable: {
            enabled: true,
            showGhost: true
          },
          movable: {
            free: false,
            color: 'white',
            dests: compute_dests(),
            events: {
              after: (orig, dest) => {
                const moves = game.moves({ square: orig, verbose: true });
                const move = moves.find(m => m.to === dest);

                if (move && move.promotion) {
                  pendingPromotion = { orig, dest };
                  overlay.classList.remove('hidden');
                } else {
                  apply_move(orig, dest, 'q');
                }
              }
            }
          },
          highlight: {
            lastMove: true,
            check: true
          },
          animation: {
            enabled: true,
            duration: 300
          }
        });
      });

      function update_move_list() {
        const moves = game.history();
        const tbody = document.getElementById('move-list-body');
        tbody.innerHTML = '';

        for (let i = 0; i < moves.length; i += 2) {
          const moveNumber = Math.floor(i / 2) + 1;
          const whiteMove = moves[i] || '';
          const blackMove = moves[i + 1] || '';
          const row = document.createElement('tr');
          row.innerHTML = `
                            <td>${moveNumber}</td>
                            <td>${whiteMove}</td>
                            <td>${blackMove}</td>
                          `;
          tbody.appendChild(row);
        }

        // Auto scroll to bottom
        tbody.parentElement.scrollTop = tbody.parentElement.scrollHeight;
      }

      document.querySelectorAll('.flip-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          isFlipped = !isFlipped;
          ground.set({ orientation: isFlipped ? 'black' : 'white' });
        });
      });

      // Initialize displays
      displayCapturedPieces();
      updateMaterialAdvantage();
    });
  </script>

</body>

</html>