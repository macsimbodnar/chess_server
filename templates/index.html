<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Chesso</title>
  <link href="/static/img/chesspieces/wikipedia/bQ.png" rel="icon" type="image/x-icon" />
  <link href="static/css/bootstrap.min.css" rel="stylesheet" />
  <link href="static/css/styles.css" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/chessground@9.1.1/assets/chessground.base.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/chessground@9.1.1/assets/chessground.brown.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/chessground@9.1.1/assets/chessground.cburnett.css" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
</head>

<body>

  <div id="main-container">
    <h1 class="title">Chesso</h1>

    <div id="board-and-moves">

      <div id="board-container"></div>

      <!-- INFO PANEL -->
      <div id="move-list-panel">
        <!-- CAPTURED PIECES -->
        <div id="captured-pieces-display">
          <div class="captured-row">
            <div id="white-captures" class="captured-pieces">
              <span class="piece-letter piece-black">W: </span>
            </div>
          </div>
          <div class="captured-row">
            <div id="black-captures" class="captured-pieces">
              <span class="piece-letter piece-black">B: </span>
            </div>
          </div>
          <div id="material-advantage"></div>
        </div>

        <!-- MOVE LIST -->
        <div id="move-list-wrapper">
          <table id="move-list-table">
            <thead>
              <tr>
                <th>#</th>
                <th>White</th>
                <th>Black</th>
              </tr>
            </thead>
            <tbody id="move-list-body"></tbody>
          </table>
        </div>
        <!-- Desktop Control Buttons -->
        <div id="move-panel-footer" class="d-none d-md-block">
          <div class="control-buttons">
            <button id="prev-move-button" class="nav-btn" disabled><i class="fas fa-chevron-left"></i></button>
            <button id="flip-button" class="flip-btn"><i class="fas fa-retweet"></i></button>
            <button id="next-move-button" class="nav-btn" disabled><i class="fas fa-chevron-right"></i></button>
            <button id="engine-move-button" class="nav-btn"><i class="fas fa-robot"></i></button>
          </div>
        </div>
      </div>
    </div>

    <!-- Mobile Control Buttons (fixed at bottom) -->
    <div id="mobile-control-btns" class="d-block d-md-none fixed-bottom p-2" style="background-color: #1f1f1f;">
      <div class="control-buttons">
        <button id="prev-move-button-mobile" class="nav-btn" disabled><i class="fas fa-chevron-left"></i></button>
        <button id="flip-button-mobile" class="flip-btn"><i class="fas fa-retweet"></i></button>
        <button id="next-move-button-mobile" class="nav-btn" disabled><i class="fas fa-chevron-right"></i></button>
        <button id="engine-move-button-mobile" class="nav-btn"><i class="fas fa-robot"></i></button>
      </div>
    </div>

  </div>
  <!-- PROMOTION -->
  <div id="promotion-overlay" class="hidden">
    <div id="promotion-dialog">
      <p>Choose promotion:</p>
      <div class="promotion-options">
        <button data-piece="q">♕</button>
        <button data-piece="r">♖</button>
        <button data-piece="b">♗</button>
        <button data-piece="n">♘</button>
      </div>
    </div>
  </div>

  <!-- COLOR SELECTION OVERLAY -->
  <div id="color-select-overlay" class="overlay">
    <div class="overlay-dialog">
      <h2>Choose Your Color</h2>
      <div class="color-options">
        <button class="color-btn" data-color="white">
          <div class="piece-icon white-piece">♔</div>
          <span>White</span>
        </button>
        <button class="color-btn" data-color="black">
          <div class="piece-icon black-piece">♚</div>
          <span>Black</span>
        </button>
      </div>
    </div>
  </div>
  <!-- GAME OVER --><!-- Update the game over overlay to include color selection -->
  <div id="gameover-overlay" class="overlay hidden">
    <div class="overlay-dialog">
      <h2 id="gameover-message">White Wins</h2>
      <div class="game-options">
        <div class="color-options mt-3">
          <button class="color-btn" data-color="white">
            <div class="piece-icon white-piece">♔</div>
            <span>White</span>
          </button>
          <button class="color-btn" data-color="black">
            <div class="piece-icon black-piece">♚</div>
            <span>Black</span>
          </button>
        </div>
      </div>
    </div>
  </div>


  <script src="static/js/jquery-3.5.1.min.js"></script>
  <script src="static/js/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.1/chess.js"
    integrity="sha384-8sJV/krC8iV2g7t0PolQxFVckDtxhfM5gNHNAFPG2ZS/bScudOjfsB8ewhG2xle8"
    crossorigin="anonymous"></script>
  <script type="module">
    import { Chessground } from 'https://cdn.jsdelivr.net/npm/chessground@9.1.1/dist/chessground.js';

    document.addEventListener('DOMContentLoaded', () => {
      const game = new Chess();
      const boardElement = document.getElementById('board-container');
      const overlay = document.getElementById('promotion-overlay');
      let pendingPromotion = null;
      let isFlipped = false;
      let capturedPieces = { w: [], b: [] };
      let waitingForEngineResponse = false;
      let playerColor = 'w'; // Default: player is white
      let engineColor = 'b'; // Default: engine is black

      // Show the color selection overlay when the page loads
      const colorSelectOverlay = document.getElementById('color-select-overlay');

      // Handle color selection from any overlay
      document.querySelectorAll('.color-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const selectedColor = e.currentTarget.dataset.color;
          playerColor = selectedColor === 'white' ? 'w' : 'b';
          engineColor = playerColor === 'w' ? 'b' : 'w';

          // Hide both overlays
          colorSelectOverlay.classList.add('hidden');
          gameoverOverlay.classList.add('hidden');

          // Reset game
          resetGame();

          // If player is black, make engine move first
          if (playerColor === 'b') {
            setTimeout(() => {
              make_engine_move();
            }, 500);
          }
        });
      });

      // Function to reset game (extract from newgame button handler)
      function resetGame() {
        game.reset();
        document.getElementById('move-list-body').innerHTML = '';

        // Reset captured pieces
        capturedPieces = { w: [], b: [] };
        displayCapturedPieces();
        updateMaterialAdvantage();

        // Reset move history
        gameMoves = [];
        boardStates = ['rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'];
        currentMoveIndex = 0;

        // Reset navigation buttons
        updateNavButtons();

        // Reset flags
        waitingForEngineResponse = false;

        // Reset the board
        ground.set({
          fen: game.fen(),
          orientation: playerColor === 'w' ? (isFlipped ? 'black' : 'white') : (isFlipped ? 'white' : 'black'),
          turnColor: 'white',
          movable: {
            color: game.turn() === playerColor ? (game.turn() === 'w' ? 'white' : 'black') : 'none',
            dests: compute_dests()
          },
          lastMove: undefined
        });
      }
      // Current move tracking for history navigation
      let currentMoveIndex = -1;
      let gameMoves = [];
      let boardStates = ['rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1']; // Starting position

      // Material values for calculating advantage
      const pieceValues = {
        p: 1,   // pawn
        n: 3,   // knight
        b: 3,   // bishop
        r: 5,   // rook
        q: 9,   // queen
        k: 0    // king (no material value)
      };

      // Display symbols for pieces (respecting chess convention)
      const pieceDisplaySymbols = {
        w: {
          p: 'P', n: 'N', b: 'B', r: 'R', q: 'Q'
        },
        b: {
          p: 'p', n: 'n', b: 'b', r: 'r', q: 'q'
        }
      };


      // Initialize the chess board with Chessground
      const ground = Chessground(boardElement, {
        orientation: 'white',
        turnColor: 'white',
        movable: {
          free: false,
          color: 'white',
          dests: compute_dests(),
          events: {
            after: onMove
          }
        },
        premovable: {
          enabled: false
        },
        draggable: {
          enabled: true,
          showGhost: true
        },
        coordinates: true,
        highlight: {
          lastMove: true,
          check: true
        },
        animation: {
          enabled: true,
          duration: 300
        },
        fen: game.fen()
      });


      // Calculate all possible destinations for each piece
      function compute_dests() {
        const dests = new Map();
        game.SQUARES.forEach(sq => {
          const ms = game.moves({ square: sq, verbose: true });
          if (ms.length) {
            dests.set(sq, ms.map(m => m.to));
          }
        });
        return dests;
      }

      // Handle piece movements
      function onMove(orig, dest) {
        // Only allow moves if it's the player's turn
        // if (game.turn() !== playerColor) {
        //   console.log("Not player's turn");
        //   return;
        // }

        const moves = game.moves({ square: orig, verbose: true });
        const move = moves.find(m => m.to === dest);

        if (move && move.promotion) {
          pendingPromotion = { orig, dest };
          overlay.classList.remove('hidden');
        } else {
          make_move(orig, dest, 'q'); // Default to queen for promotion if not handled
        }
      }

      // Apply the move to both the chess.js game and the Chessground board
      function make_move(orig, dest, promotion) {
        // Only allow player to move their own pieces
        // if (game.turn() !== playerColor) {
        //   console.log("Not player's turn");
        //   return false;
        // }

        const move = game.move({ from: orig, to: dest, promotion });
        if (move) {
          // Handle captures
          if (move.captured) {
            updateCapturedPieces(move.captured, move.color === 'w' ? 'b' : 'w');
          }

          // Save move for history navigation
          gameMoves.push({ from: orig, to: dest, promotion });
          boardStates.push(game.fen());
          currentMoveIndex = boardStates.length - 1;

          // Update the board display
          ground.set({
            fen: game.fen(),
            lastMove: [orig, dest],
            turnColor: game.turn() === 'w' ? 'white' : 'black',
            movable: {
              color: game.turn() === 'w' ? 'white' : 'black',
              dests: compute_dests()
            }
          });

          // Update UI components
          updateNavButtons();
          check_gameover();
          update_move_list();
          updateMaterialAdvantage();

          // Automatically make engine move if it's engine's turn
          if (!game.game_over() && game.turn() === engineColor && !waitingForEngineResponse) {
            setTimeout(() => {
              make_engine_move();
            }, 300);
          }

          return true;
        }

        return false;
      }

      function updateCapturedPieces(pieceType, color) {
        capturedPieces[color].push(pieceType);
        displayCapturedPieces();
      }

      function displayCapturedPieces() {
        const whiteCapturesElement = document.getElementById('white-captures');
        const blackCapturesElement = document.getElementById('black-captures');

        whiteCapturesElement.innerHTML = '<span class="piece-letter piece-black">W: </span>';
        blackCapturesElement.innerHTML = '<span class="piece-letter piece-black">B: </span>';

        // Sort pieces by value before displaying
        capturedPieces.w.sort((a, b) => pieceValues[b] - pieceValues[a]);
        capturedPieces.b.sort((a, b) => pieceValues[b] - pieceValues[a]);

        // Display white's captured pieces (captured by black)
        capturedPieces.w.forEach(piece => {
          const pieceElem = document.createElement('span');
          pieceElem.className = 'piece-letter piece-white';
          pieceElem.textContent = pieceDisplaySymbols.w[piece] || piece.toUpperCase();
          blackCapturesElement.appendChild(pieceElem);
        });

        // Display black's captured pieces (captured by white)
        capturedPieces.b.forEach(piece => {
          const pieceElem = document.createElement('span');
          pieceElem.className = 'piece-letter piece-black';
          pieceElem.textContent = pieceDisplaySymbols.b[piece] || piece.toLowerCase();
          whiteCapturesElement.appendChild(pieceElem);
        });
      }

      function updateMaterialAdvantage() {
        const advantageElement = document.getElementById('material-advantage');

        // Calculate material advantage
        let whiteMaterial = 0;
        let blackMaterial = 0;

        // Add up material for all pieces on the board
        const position = game.board();
        for (let i = 0; i < 8; i++) {
          for (let j = 0; j < 8; j++) {
            const square = position[i][j];
            if (square) {
              if (square.color === 'w') {
                whiteMaterial += pieceValues[square.type];
              } else {
                blackMaterial += pieceValues[square.type];
              }
            }
          }
        }

        const advantage = whiteMaterial - blackMaterial;

        // Display the advantage
        if (advantage > 0) {
          advantageElement.textContent = `White: +${advantage}`;
          advantageElement.style.color = '#8ff';
        } else if (advantage < 0) {
          advantageElement.textContent = `Black: +${Math.abs(advantage)}`;
          advantageElement.style.color = '#8ff';
        } else {
          advantageElement.textContent = 'Even';
          advantageElement.style.color = '#f5f5f5';
        }
      }

      // Handle promotion piece selection
      document.querySelectorAll('.promotion-options button').forEach(btn => {
        btn.addEventListener('click', () => {
          if (pendingPromotion) {
            const piece = btn.dataset.piece;
            make_move(pendingPromotion.orig, pendingPromotion.dest, piece);
            pendingPromotion = null;
            overlay.classList.add('hidden');
          }
        });
      });

      const gameoverOverlay = document.getElementById('gameover-overlay');
      const gameoverMessage = document.getElementById('gameover-message');

      // Check if game is over and display appropriate message
      function check_gameover() {
        if (game.game_over()) {
          let message = '';
          if (game.in_checkmate()) {
            message = game.turn() === 'w' ? 'Black Wins' : 'White Wins';
          } else if (game.in_stalemate()) {
            message = 'Stalemate';
          } else if (game.in_draw()) {
            message = 'Draw';
          } else if (game.in_threefold_repetition()) {
            message = 'Draw by Repetition';
          } else if (game.insufficient_material()) {
            message = 'Draw by Insufficient Material';
          }

          gameoverMessage.textContent = message;
          gameoverOverlay.classList.remove('hidden');

          ground.set({
            movable: { color: 'none', dests: new Map() }
          });
        }
      }

      function update_move_list() {
        const moves = game.history();
        const tbody = document.getElementById('move-list-body');
        tbody.innerHTML = '';

        for (let i = 0; i < moves.length; i += 2) {
          const moveNumber = Math.floor(i / 2) + 1;
          const whiteMove = moves[i] || '';
          const blackMove = moves[i + 1] || '';
          const row = document.createElement('tr');

          // Highlight the current move
          const isCurrentRow = (i === currentMoveIndex || i + 1 === currentMoveIndex);
          if (isCurrentRow) {
            row.classList.add('current-move-row');
          }

          row.innerHTML = `
            <td>${moveNumber}</td>
            <td class="${i === currentMoveIndex ? 'current-move' : ''}">${whiteMove}</td>
            <td class="${i + 1 === currentMoveIndex ? 'current-move' : ''}">${blackMove}</td>
          `;
          tbody.appendChild(row);
        }

        // Auto scroll to bottom
        const moveList = document.getElementById('move-list-wrapper');
        moveList.scrollTop = moveList.scrollHeight;
      }

      // Move history navigation functions
      function goToPrevMove() {
        if (currentMoveIndex > 0) {
          currentMoveIndex--;

          // Create a new chess instance to view this position
          const viewGame = new Chess();
          viewGame.load(boardStates[currentMoveIndex]);

          // Update the board display only
          ground.set({
            fen: viewGame.fen(),
            lastMove: currentMoveIndex > 0 ? [
              gameMoves[currentMoveIndex - 1].from,
              gameMoves[currentMoveIndex - 1].to
            ] : undefined,
            movable: {
              color: 'none', // Disable moves during history viewing
              dests: new Map()
            }
          });

          // Update move list highlighting
          update_move_list_highlighting();
          updateNavButtons();
        }
      }

      function goToNextMove() {
        if (currentMoveIndex < boardStates.length - 1) {
          currentMoveIndex++;

          // Create a new chess instance to view this position
          const viewGame = new Chess();
          viewGame.load(boardStates[currentMoveIndex]);

          // Update the board display only
          ground.set({
            fen: viewGame.fen(),
            lastMove: [
              gameMoves[currentMoveIndex - 1].from,
              gameMoves[currentMoveIndex - 1].to
            ],
            movable: {
              color: 'none', // Disable moves during history viewing
              dests: new Map()
            }
          });

          // If we're back at the current game state, re-enable moves
          if (currentMoveIndex === boardStates.length - 1) {
            const currentTurn = game.turn();
            ground.set({
              turnColor: currentTurn === 'w' ? 'white' : 'black',
              movable: {
                color: currentTurn === playerColor ? (currentTurn === 'w' ? 'white' : 'black') : 'none',
                dests: compute_dests()
              }
            });
          }

          // Update move list highlighting
          update_move_list_highlighting();
          updateNavButtons();
        }
      }

      function update_move_list_highlighting() {
        // Remove all highlighting
        const cells = document.querySelectorAll('#move-list-body td');
        cells.forEach(cell => {
          cell.classList.remove('current-move');
        });

        // Add highlighting to current move
        const moveIndex = currentMoveIndex;
        const isWhiteMove = moveIndex % 2 === 0;
        const rowIndex = Math.floor(moveIndex / 2);

        const rows = document.querySelectorAll('#move-list-body tr');
        if (rows[rowIndex]) {
          // +1 because first column is the move number
          const cellIndex = isWhiteMove ? 1 : 2;
          const cell = rows[rowIndex].cells[cellIndex];
          if (cell) {
            cell.classList.add('current-move');
          }
        }
      }

      function updateNavButtons() {
        // Update desktop buttons
        document.getElementById('prev-move-button').disabled = currentMoveIndex <= 0;
        document.getElementById('next-move-button').disabled = currentMoveIndex >= boardStates.length - 1;

        // Update mobile buttons
        document.getElementById('prev-move-button-mobile').disabled = currentMoveIndex <= 0;
        document.getElementById('next-move-button-mobile').disabled = currentMoveIndex >= boardStates.length - 1;
      }

      // Attach event listeners for navigation buttons
      document.getElementById('prev-move-button').addEventListener('click', goToPrevMove);
      document.getElementById('next-move-button').addEventListener('click', goToNextMove);
      document.getElementById('prev-move-button-mobile').addEventListener('click', goToPrevMove);
      document.getElementById('next-move-button-mobile').addEventListener('click', goToNextMove);

      // Flip board buttons
      document.querySelectorAll('.flip-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          isFlipped = !isFlipped;
          ground.set({ orientation: isFlipped ? 'black' : 'white' });
        });
      });

      // Make the engine move
      function make_engine_move() {
        if (game.game_over() || waitingForEngineResponse) {
          return;
        }

        waitingForEngineResponse = true;
        let depth = 4;
        let time = 0;

        // Disable board during engine thinking
        ground.set({
          movable: {
            color: 'none',
            dests: new Map()
          }
        });

        console.log("Engine thinking...");

        $.ajax({
          url: '/make_move',
          type: 'POST',
          contentType: 'application/json',
          data: JSON.stringify({
            fen: game.fen(),
            depth: depth.toString(),
            time: time.toString()
          }),
          success: function (response) {
            console.log("Engine response:", response);

            // Get the move details before applying it
            const move = game.move(response.best_move, { sloppy: true });

            if (move) {
              console.log("Engine move:", move);

              // Check for captures
              if (move.captured) {
                updateCapturedPieces(move.captured, move.color === 'w' ? 'b' : 'w');
              }

              // Save move for history navigation
              gameMoves.push({
                from: move.from,
                to: move.to,
                promotion: move.promotion
              });
              boardStates.push(game.fen());
              currentMoveIndex = boardStates.length - 1;

              // Update the board
              ground.set({
                fen: game.fen(),
                lastMove: [move.from, move.to],
                turnColor: game.turn() === 'w' ? 'white' : 'black'
              });

              // Re-enable player moves if it's their turn
              if (game.turn() === playerColor) {
                console.log("Re-enabling player moves");
                ground.set({
                  movable: {
                    color: game.turn() === 'w' ? 'white' : 'black',
                    dests: compute_dests()
                  }
                });
              }

              // Update all the UI elements and statuses
              updateNavButtons();
              check_gameover();
              update_move_list();
              updateMaterialAdvantage();
            }
            waitingForEngineResponse = false;
          },
          error: function (xhr, status, error) {
            console.error('Engine move error:', error);
            waitingForEngineResponse = false;

            // Re-enable board interaction on error
            if (game.turn() === playerColor) {
              ground.set({
                movable: {
                  color: game.turn() === 'w' ? 'white' : 'black',
                  dests: compute_dests()
                }
              });
            }
          }
        });
      }

      // Attach event listeners for engine move buttons
      document.getElementById('engine-move-button').addEventListener('click', () => {
        if (game.turn() === playerColor) {
          // If it's player's turn, make the move for the player
          console.log("Making move for player...");
          make_engine_move();
        } else {
          // If it's engine's turn, continue with normal engine move
          make_engine_move();
        }
      });

      document.getElementById('engine-move-button-mobile').addEventListener('click', () => {
        if (game.turn() === playerColor) {
          // If it's player's turn, make the move for the player
          console.log("Making move for player...");
          make_engine_move();
        } else {
          // If it's engine's turn, continue with normal engine move
          make_engine_move();
        }
      });

      // Initialize displays
      displayCapturedPieces();
      updateMaterialAdvantage();
      updateNavButtons();
    });
  </script>

</body>

</html>