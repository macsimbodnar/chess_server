<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Chesso</title>
  <link href="/static/img/chesspieces/wikipedia/bQ.png" rel="icon" type="image/x-icon" />
  <link href="static/css/bootstrap.min.css" rel="stylesheet" />
  <link href="static/css/styles.css" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/chessground@9.1.1/assets/chessground.base.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/chessground@9.1.1/assets/chessground.brown.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/chessground@9.1.1/assets/chessground.cburnett.css" rel="stylesheet">
</head>

<body>

  <div id="main-container">
    <h1 class="title">Chesso</h1>

    <div id="board-and-moves">
      
      <div id="board-container"></div>

      <!-- INFO PANEL -->
      <div id="move-list-panel">
        <!-- MOVE LIST -->
        <div id="move-list-wrapper">
          <table id="move-list-table">
            <thead>
              <tr>
                <th>#</th>
                <th>White</th>
                <th>Black</th>
              </tr>
            </thead>
            <tbody id="move-list-body"></tbody>
          </table>
        </div>
        <!-- Desktop Flip Button -->
        <div id="move-panel-footer" class="d-none d-md-block">
          <button id="flip-button" class="flip-btn">Flip Board</button>
        </div>
      </div>
    </div>

    <!-- Mobile Flip Button (fixed at bottom) -->
    <div id="mobile-flip-btn" class="d-block d-md-none fixed-bottom p-2" style="background-color: #1f1f1f;">
      <button id="flip-button-mobile" class="btn btn-secondary btn-block flip-btn">Flip Board</button>
    </div>

  </div>
  <!-- PROMOTION -->
  <div id="promotion-overlay" class="hidden">
    <div id="promotion-dialog">
      <p>Choose promotion:</p>
      <div class="promotion-options">
        <button data-piece="q">♕</button>
        <button data-piece="r">♖</button>
        <button data-piece="b">♗</button>
        <button data-piece="n">♘</button>
      </div>
    </div>
  </div>
  <!-- GAME OVER -->
  <div id="gameover-overlay" class="hidden">
    <div id="gameover-dialog">
      <h2 id="gameover-message">White Wins</h2>
      <button id="newgame-button">New Game</button>
    </div>
  </div>

  <script src="static/js/jquery-3.5.1.min.js"></script>
  <script src="static/js/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.1/chess.js"
    integrity="sha384-8sJV/krC8iV2g7t0PolQxFVckDtxhfM5gNHNAFPG2ZS/bScudOjfsB8ewhG2xle8"
    crossorigin="anonymous"></script>
  <script type="module">
    import { Chessground } from 'https://cdn.jsdelivr.net/npm/chessground@9.1.1/dist/chessground.js';

    document.addEventListener('DOMContentLoaded', () => {
      const game = new Chess();
      const boardElement = document.getElementById('board-container');
      const overlay = document.getElementById('promotion-overlay');
      let pendingPromotion = null;
      let isFlipped = false;

      const ground = Chessground(boardElement, {
        draggable: {
          enabled: true,
          showGhost: true
        },
        movable: {
          free: false,
          color: 'white',
          dests: compute_dests(),
          events: {
            after: (orig, dest) => {
              const moves = game.moves({ square: orig, verbose: true });
              const move = moves.find(m => m.to === dest);

              if (move && move.promotion) {
                pendingPromotion = { orig, dest };
                overlay.classList.remove('hidden');
              } else {
                apply_move(orig, dest, 'q'); // normal move
              }
            }
          }
        },
        highlight: {
          lastMove: true,
          check: true
        },
        animation: {
          enabled: true,
          duration: 300
        },
        fen: game.fen()
      });

      function compute_dests() {
        const dests = new Map();
        game.SQUARES.forEach(sq => {
          const moves = game.moves({ square: sq, verbose: true });
          if (moves.length) {
            dests.set(sq, moves.map(m => m.to));
          }
        });
        return dests;
      }

      function apply_move(orig, dest, promotion) {
        const move = game.move({ from: orig, to: dest, promotion });
        if (move) {
          ground.set({
            fen: game.fen(),
            movable: {
              color: game.turn() === 'w' ? 'white' : 'black',
              dests: compute_dests()
            }
          });

          check_gameover(); // ✅ here
          update_move_list();
        }
      }


      document.querySelectorAll('.promotion-options button').forEach(btn => {
        btn.addEventListener('click', () => {
          if (pendingPromotion) {
            const piece = btn.dataset.piece;
            apply_move(pendingPromotion.orig, pendingPromotion.dest, piece);
            pendingPromotion = null;
            overlay.classList.add('hidden');
          }
        });
      });

      const gameoverOverlay = document.getElementById('gameover-overlay');
      const gameoverMessage = document.getElementById('gameover-message');
      const newgameButton = document.getElementById('newgame-button');

      // Check if game is over and show overlay
      function check_gameover() {
        if (game.game_over()) {
          const winner = game.in_draw() ? 'Draw' : (game.turn() === 'w' ? 'Black Wins' : 'White Wins');
          gameoverMessage.textContent = winner;
          gameoverOverlay.classList.remove('hidden');

          ground.set({
            movable: { color: null, dests: new Map() } // ⛔ disable interaction
          });
        }
      }

      // New game button resets everything
      newgameButton.addEventListener('click', () => {
        game.reset();
        gameoverOverlay.classList.add('hidden');
        document.getElementById('move-list-body').innerHTML = '';

        ground.set({
          fen: game.fen(),
          turnColor: 'white',
          draggable: {
            enabled: true,
            showGhost: true
          },
          movable: {
            free: false,
            color: 'white',
            dests: compute_dests(),
            events: {
              after: (orig, dest) => {
                const moves = game.moves({ square: orig, verbose: true });
                const move = moves.find(m => m.to === dest);

                if (move && move.promotion) {
                  pendingPromotion = { orig, dest };
                  overlay.classList.remove('hidden');
                } else {
                  apply_move(orig, dest, 'q');
                }
              }
            }
          },
          highlight: {
            lastMove: true,
            check: true
          },
          animation: {
            enabled: true,
            duration: 300
          }
        });
      });

      function update_move_list() {
        const moves = game.history();
        const tbody = document.getElementById('move-list-body');
        tbody.innerHTML = '';

        for (let i = 0; i < moves.length; i += 2) {
          const moveNumber = Math.floor(i / 2) + 1;
          const whiteMove = moves[i] || '';
          const blackMove = moves[i + 1] || '';
          const row = document.createElement('tr');
          row.innerHTML = `
                            <td>${moveNumber}</td>
                            <td>${whiteMove}</td>
                            <td>${blackMove}</td>
                          `;
          tbody.appendChild(row);
        }

        // Auto scroll to bottom
        tbody.parentElement.scrollTop = tbody.parentElement.scrollHeight;
      }


      document.querySelectorAll('.flip-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          isFlipped = !isFlipped;
          ground.set({ orientation: isFlipped ? 'black' : 'white' });
        });
      });


    });


  </script>

</body>


</html>